import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';

export interface PDFOptions {
  title: string;
  content: string;
  author?: string;
  fontSize?: number;
  lineHeight?: number;
}

export async function generatePDF(options: PDFOptions): Promise<Buffer> {
  const {
    title,
    content,
    author = 'AI Assistant',
    fontSize = 12,
    lineHeight = 1.4
  } = options;

  // Create a new PDF document
  const pdfDoc = await PDFDocument.create();
  
  // Set document metadata
  pdfDoc.setTitle(title);
  pdfDoc.setAuthor(author);
  pdfDoc.setCreator('AI Content Generator');
  pdfDoc.setProducer('Cash Drive Platform');
  pdfDoc.setCreationDate(new Date());

  // Embed fonts
  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);

  // Page setup
  const pageWidth = 595.28; // A4 width in points
  const pageHeight = 841.89; // A4 height in points
  const margin = 50;
  const maxWidth = pageWidth - (margin * 2);

  let currentPage = pdfDoc.addPage([pageWidth, pageHeight]);
  let yPosition = pageHeight - margin;

  // Helper function to add a new page
  const addNewPage = () => {
    currentPage = pdfDoc.addPage([pageWidth, pageHeight]);
    yPosition = pageHeight - margin;
  };

  // Helper function to check if we need a new page
  const checkPageBreak = (requiredHeight: number) => {
    if (yPosition - requiredHeight < margin) {
      addNewPage();
    }
  };

  // Helper function to wrap text
  const wrapText = (text: string, font: any, fontSize: number, maxWidth: number): string[] => {
    // First, handle newlines by splitting into separate lines
    const inputLines = text.split('\n');
    const outputLines: string[] = [];

    for (const inputLine of inputLines) {
      if (inputLine.trim() === '') {
        // Empty line
        outputLines.push('');
        continue;
      }

      // Clean the text to remove problematic characters for PDF encoding
      const cleanLine = inputLine
        .replace(/[^\x20-\x7E\u00A0-\u00FF]/g, '') // Keep only printable ASCII and Latin-1 characters
        .trim();

      if (!cleanLine) {
        outputLines.push('');
        continue;
      }

      const words = cleanLine.split(' ');
      let currentLine = '';

      for (const word of words) {
        const testLine = currentLine ? `${currentLine} ${word}` : word;
        
        try {
          const testWidth = font.widthOfTextAtSize(testLine, fontSize);
          
          if (testWidth <= maxWidth) {
            currentLine = testLine;
          } else {
            if (currentLine) {
              outputLines.push(currentLine);
              currentLine = word;
            } else {
              // Word is too long, split it
              outputLines.push(word);
            }
          }
        } catch (error) {
          // If there's an encoding error, skip this word or use a fallback
          console.warn('PDF encoding error for word:', word, error);
          // Try to add the word without special characters
          const cleanWord = word.replace(/[^\x20-\x7E]/g, '');
          if (cleanWord) {
            const testCleanLine = currentLine ? `${currentLine} ${cleanWord}` : cleanWord;
            try {
              const testWidth = font.widthOfTextAtSize(testCleanLine, fontSize);
              if (testWidth <= maxWidth) {
                currentLine = testCleanLine;
              } else {
                if (currentLine) {
                  outputLines.push(currentLine);
                  currentLine = cleanWord;
                } else {
                  outputLines.push(cleanWord);
                }
              }
            } catch (cleanError) {
              // Skip this word entirely if it still causes issues
              console.warn('Skipping problematic word:', word);
            }
          }
        }
      }
      
      if (currentLine) {
        outputLines.push(currentLine);
      }
    }
    
    return outputLines;
  };

  // Draw title
  const titleFontSize = 20;
  const titleLines = wrapText(title, helveticaBoldFont, titleFontSize, maxWidth);
  const titleHeight = titleLines.length * titleFontSize * lineHeight;
  
  checkPageBreak(titleHeight + 20);
  
  for (let i = 0; i < titleLines.length; i++) {
    currentPage.drawText(titleLines[i], {
      x: margin,
      y: yPosition - (i * titleFontSize * lineHeight),
      size: titleFontSize,
      font: helveticaBoldFont,
      color: rgb(0, 0, 0),
    });
  }
  yPosition -= titleHeight + 20;

  // Draw metadata
  const metaFontSize = 10;
  const metaText = [
    `Generated by: ${author}`,
    `Date: ${new Date().toLocaleDateString()}`,
    `Generated with AI Content Creator`
  ];

  for (const meta of metaText) {
    checkPageBreak(metaFontSize * lineHeight);
    currentPage.drawText(meta, {
      x: margin,
      y: yPosition,
      size: metaFontSize,
      font: helveticaFont,
      color: rgb(0.4, 0.4, 0.4),
    });
    yPosition -= metaFontSize * lineHeight + 2;
  }

  yPosition -= 20; // Extra space after metadata

  // Process content
  const paragraphs = content.split('\n\n');

  for (const paragraph of paragraphs) {
    if (paragraph.trim()) {
      // Check if it's a header
      if (paragraph.startsWith('#')) {
        const headerLevel = (paragraph.match(/^#+/) || [''])[0].length;
        const headerText = paragraph.replace(/^#+\s*/, '');
        const headerFontSize = Math.max(14, fontSize + (4 - headerLevel));
        
        const headerLines = wrapText(headerText, helveticaBoldFont, headerFontSize, maxWidth);
        const headerHeight = headerLines.length * headerFontSize * lineHeight;
        
        checkPageBreak(headerHeight + 15);
        
        // Add some space before header
        yPosition -= 10;
        
        for (let i = 0; i < headerLines.length; i++) {
          if (headerLines[i].trim()) { // Skip empty lines
            currentPage.drawText(headerLines[i], {
              x: margin,
              y: yPosition - (i * headerFontSize * lineHeight),
              size: headerFontSize,
              font: helveticaBoldFont,
              color: rgb(0, 0, 0),
            });
          }
        }
        
        yPosition -= headerHeight + 10;
      } else {
        // Regular paragraph
        const paragraphLines = wrapText(paragraph, helveticaFont, fontSize, maxWidth);
        const paragraphHeight = paragraphLines.length * fontSize * lineHeight;
        
        checkPageBreak(paragraphHeight + 10);
        
        for (let i = 0; i < paragraphLines.length; i++) {
          if (paragraphLines[i].trim()) { // Skip empty lines
            currentPage.drawText(paragraphLines[i], {
              x: margin,
              y: yPosition - (i * fontSize * lineHeight),
              size: fontSize,
              font: helveticaFont,
              color: rgb(0, 0, 0),
            });
          }
        }
        
        yPosition -= paragraphHeight + 12; // Extra space between paragraphs
      }
    }
  }

  // Add page numbers
  const pages = pdfDoc.getPages();
  const totalPages = pages.length;
  
  for (let i = 0; i < totalPages; i++) {
    const page = pages[i];
    const pageNumber = `Page ${i + 1} of ${totalPages}`;
    const pageNumberWidth = helveticaFont.widthOfTextAtSize(pageNumber, 8);
    
    page.drawText(pageNumber, {
      x: pageWidth - margin - pageNumberWidth,
      y: margin - 20,
      size: 8,
      font: helveticaFont,
      color: rgb(0.5, 0.5, 0.5),
    });
  }

  // Generate PDF buffer
  const pdfBytes = await pdfDoc.save();
  return Buffer.from(pdfBytes);
}

export function calculateEstimatedPrice(content: string): number {
  const wordCount = content.split(/\s+/).length;
  const basePrice = Math.max(1, Math.ceil(wordCount / 500));
  return basePrice;
} 